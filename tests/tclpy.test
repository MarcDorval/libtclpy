if {[lsearch [namespace children] ::tcltest] == -1} {
	package require tcltest
	namespace import ::tcltest::*
}

package require tclpy

# =========
# PY
# =========
test py-1.1 {incorrect usage} {
	list [catch {py} errMsg] $errMsg
} {1 {wrong # args: should be "py subcommand ?arg ...?"}}

# =========
# PY EVAL
# =========
test py_eval-1.1 {incorrect eval usage} {
	list [catch {py eval} errMsg1] $errMsg1\
	     [catch {py eval {print 1} {print 2}} errMsg2] $errMsg2
} {1 {wrong # args: should be "py eval evalString"}\
   1 {wrong # args: should be "py eval evalString"}}

test py_eval-1.2 {eval returns nothing} {
	list [py eval {1+1}]
} {{}}

test py_eval-1.2 {basic eval} -setup {
	set randdir tmp_[expr {rand()}]
} -body {
	py eval "def mk(dir): os.mkdir(dir)"
	py eval "import os; mk('$randdir')"
	file isdirectory $randdir
} -result {1} -cleanup {
	file delete $randdir
}

# =========
# PY IMPORT
# =========
test py_import-1.1 {incorrect import usage} {
	list [catch {py import} errMsg1] $errMsg1\
	     [catch {py import -from os} errMsg2] $errMsg2
} {1 {wrong # args: should be "py import module"}\
   1 {wrong # args: should be "py import module"}}

test py_import-1.2 {basic import} -body {
	py import re
	py eval "import sys; assert 're' in sys.modules; assert 're' in globals()"
} -result {}

test py_import-1.3 {submodule import} -body {
	py import xml.dom
	py eval "import sys; assert 'dom' in dir(xml)"
} -result {}

test py_import-1.4 {non-existent import} -body {
	py eval {a = lambda: 1/0}
	list [catch {py import aosidas} err] $err
} -result {1 {No module named aosidas}}

# =========
# PY CALL
# =========
test py_call-1.1 {incorrect call usage} {
	list [catch {py call} errMsg1] $errMsg1
} {1 {wrong # args: should be "py call func ?arg ...?"}}

test py_call-1.2 {basic call} {
	py eval {def a(): return 5**2}
	py call a
} {25}

test py_call-1.3 {basic call with args} {
	py eval {def a(x,y): return x+y}
	py call a string1 string2
} {string1string2}

test py_call-1.4 {call of module function} {
	py import base64
	py call base64.b64decode YXRlc3Q=
} {atest}

test py_call-1.5 {call of object methods} {
	py import StringIO
	py eval {a = StringIO.StringIO(); a.write('btest'); a.seek(0)}
	py call a.read
} {btest}

test py_call-1.6 {basic call with complex types} {
	py eval {def a(): return [(1,2),["a","b"],{"x":3,"y":4}]}
	py call a
} {[(1, 2), ['a', 'b'], {'y': 4, 'x': 3}]}

test py_call-1.7 {simple call exception} {
	py eval {a = lambda: 1/0}
	list [catch {py call a} err] $err
} {1 {integer division or modulo by zero}}

test py_call-1.8 {stacked call exception} {
	py eval {def a(): return 5 + dict()}
	py eval {def b(): return a()}
	py eval {def c(): return b()}
	list [catch {py call c} err] $err
} {1 {unsupported operand type(s) for +: 'int' and 'dict'}}

# =========
# cleanup
# =========
::tcltest::cleanupTests
return

